/**
 * Jenkinsfile final pour l'Atelier CI/CD Kubernetes / Spring Boot.
 * Inclut le correctif 'withEnv' pour les probl√®mes de permission kubectl/Minikube sous WSL.
 */
pipeline {
    agent any 

    environment {
        // Nom complet de l'image Docker (votre compte Docker Hub)
        DOCKER_IMAGE = "dhiaayadi/dhiaayadii" 
        
        // Nom du Deployment Kubernetes cible
        K8S_DEPLOYMENT_NAME = "spring-deployment" 
        
        // Namespace Kubernetes
        NAMESPACE = "devops"
        
        // ID de l'identifiant Docker Hub stock√© dans Jenkins (√† v√©rifier dans Manage Credentials)
        DOCKER_CREDENTIALS_ID = "docker-hub-credentials" 
    }

    stages {
        // √âtape 1 : R√©cup√©ration du code source
        stage('1. Checkout Code') {
            steps {
                echo "--> √âtape 1 : R√©cup√©ration du code depuis Git."
                checkout scm
            }
        }

        // √âtape 2 : Compilation et Tests (avec Maven)
        stage('2. Build & Package') {
            steps {
                echo "--> √âtape 2 : Compilation du projet Spring Boot."
                sh 'mvn clean package -DskipTests' 
            }
        }

        // √âtape 3 : Dockerisation et Push
        stage('3. Docker Build & Push') {
            steps {
                script {
                    def imageTag = "${env.DOCKER_IMAGE}:${env.BUILD_NUMBER}"
                    
                    echo "Construction de l'image Docker avec le tag : ${imageTag}"
                    sh "docker build -t ${imageTag} ."

                    // Utilise les identifiants stock√©s dans Jenkins pour se connecter √† Docker Hub
                    withCredentials([usernamePassword(credentialsId: env.DOCKER_CREDENTIALS_ID, passwordVariable: 'DOCKER_PASSWORD', usernameVariable: 'DOCKER_USERNAME')]) {
                        echo "Connexion et Push vers Docker Hub..."
                        
                        sh "docker login -u ${DOCKER_USERNAME} -p ${DOCKER_PASSWORD}"
                        
                        sh "docker push ${imageTag}"
                    }
                }
            }
        }

        // √âtape 4 : D√©ploiement sur Kubernetes (avec correctif Kubeconfig)
        stage('4. Deploy to Kubernetes') {
            steps {
                script {
                    def imageTag = "${env.DOCKER_IMAGE}:${env.BUILD_NUMBER}"
                    echo "--> √âtape 4 : D√©ploiement sur Kubernetes de la version ${env.BUILD_NUMBER}."

                    // üõ†Ô∏è CORRECTIF WSL/PERMISSIONS : Force l'utilisation du fichier kubeconfig de Jenkins
                    withEnv(["KUBECONFIG=/var/lib/jenkins/.kube/config"]) { 
                        
                        // Met √† jour le Deployment K8s avec la nouvelle image tagu√©e
                        sh "kubectl set image deployment/${env.K8S_DEPLOYMENT_NAME} spring-container=${imageTag} -n ${env.NAMESPACE}"
                        
                        echo "D√©ploiement initi√©. Attente de la stabilisation..."

                        // Attend que tous les Pods soient pr√™ts (rolling update termin√©)
                        sh "kubectl rollout status deployment/${env.K8S_DEPLOYMENT_NAME} -n ${env.NAMESPACE} --timeout=5m"
                    }
                    
                    echo "D√©ploiement r√©ussi. Nouvelle version en ligne."
                }
            }
        }
    }
    
    post {
        always {
            echo "Pipeline termin√© avec le statut : ${currentBuild.result}"
        }
        success {
            echo "‚úÖ CI/CD SUCCESS : L'application est en ligne sur Kubernetes !"
        }
        failure {
            echo "‚ùå CI/CD FAILURE : Veuillez v√©rifier les logs. L'√©tape √©chou√©e est : ${currentBuild.stage.name}"
        }
    }
}

pipeline {
    // Configuration de l'agent : s'exécute sur n'importe quel agent (machine Jenkins)
    agent any 

    // Variables d'environnement utilisées dans les étapes
    environment {
        // Nom complet de l'image Docker (votre compte Docker Hub)
        DOCKER_IMAGE = "dhiaayadi/dhiaayadii" 
        
        // Nom du Deployment Kubernetes cible (défini dans spring-deployment.yaml)
        K8S_DEPLOYMENT_NAME = "spring-deployment" 
        
        // Namespace Kubernetes
        NAMESPACE = "devops"
        
        // ID de l'identifiant Docker Hub stocké dans Jenkins
        DOCKER_CREDENTIALS_ID = "docker-hub-credentials" 
    }

    stages {
        // Étape 1 : Récupération du code source
        stage('1. Checkout Code') {
            steps {
                echo "--> Étape 1 : Récupération du code depuis Git."
                // 'scm' est une variable Jenkins qui fait référence à la configuration SCM du job
                checkout scm
            }
        }

        // Étape 2 : Compilation et Tests (avec Maven)
        stage('2. Build & Package') {
            steps {
                echo "--> Étape 2 : Compilation du projet Spring Boot."
                // Nettoie et package l'application dans un JAR/WAR, en ignorant les tests pour aller plus vite
                sh 'mvn clean package -DskipTests' 
            }
        }

        // Étape 3 : Dockerisation et Push
        stage('3. Docker Build & Push') {
            steps {
                script {
                    // Tag dynamique utilisant le numéro de Build Jenkins
                    def imageTag = "${env.DOCKER_IMAGE}:${env.BUILD_NUMBER}"
                    
                    echo "Construction de l'image Docker avec le tag : ${imageTag}"
                    // Construit l'image Docker à l'aide du Dockerfile présent dans le répertoire de travail
                    sh "docker build -t ${imageTag} ."

                    // Utilise les identifiants stockés dans Jenkins pour la connexion
                    withCredentials([usernamePassword(credentialsId: env.DOCKER_CREDENTIALS_ID, passwordVariable: 'DOCKER_PASSWORD', usernameVariable: 'DOCKER_USERNAME')]) {
                        echo "Connexion et Push vers Docker Hub..."
                        
                        // Connexion
                        sh "docker login -u ${DOCKER_USERNAME} -p ${DOCKER_PASSWORD}"
                        
                        // Push de l'image taguée
                        sh "docker push ${imageTag}"
                    }
                }
            }
        }

        // Étape 4 : Déploiement sur Kubernetes
        stage('4. Deploy to Kubernetes') {
            steps {
                script {
                    def imageTag = "${env.DOCKER_IMAGE}:${env.BUILD_NUMBER}"
                    echo "--> Étape 4 : Déploiement sur Kubernetes de la version ${env.BUILD_NUMBER}."

                    // Commande essentielle : met à jour le Deployment K8s avec la nouvelle image
                    // kubectl set image ... est la manière la plus propre de forcer un "rollout"
                    sh "kubectl set image deployment/${env.K8S_DEPLOYMENT_NAME} spring-container=${imageTag} -n ${env.NAMESPACE}"
                    
                    echo "Déploiement initié. Attente de la stabilisation..."

                    // Vérifie que le déploiement est stable (nouveaux pods démarrés et anciens arrêtés)
                    sh "kubectl rollout status deployment/${env.K8S_DEPLOYMENT_NAME} -n ${env.NAMESPACE} --timeout=5m"
                    
                    echo "Déploiement réussi. Nouvelle version en ligne."
                }
            }
        }
    }
    
    // Actions post-build (à la fin du pipeline)
    post {
        always {
            // Afficher le statut du pipeline dans les logs
            echo "Pipeline terminé avec le statut : ${currentBuild.result}"
        }
        success {
            echo "CI/CD SUCCESS : Le déploiement est en ligne !"
        }
        failure {
            echo "CI/CD FAILURE : Veuillez vérifier les logs des étapes Docker ou Kubernetes."
        }
    }
}
